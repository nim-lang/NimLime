# coding=utf-8
"""
Commands and code to check Nim files for errors.
"""
import os.path
import re
import subprocess

import sublime
from nimlime_core import configuration
from nimlime_core.utils.error_handler import catch_errors
from nimlime_core.utils.misc import (
    view_has_nim_syntax, send_self, busy_frames, get_next_method,
    loop_status_msg, trim_region, run_process, handle_process_error)
from nimlime_core.utils.mixins import NimLimeMixin, NimLimeOutputMixin
from sublime_plugin import ApplicationCommand, EventListener

# Constants
ERROR_REGION_TAG = 'NimCheckError'
WARN_REGION_TAG = 'NimCheckWarn'
ERROR_REGION_MARK = 'dot'
ERROR_REGION_STYLE = sublime.DRAW_OUTLINED
ERROR_MSG_FORMAT = '({0},{1}): {2}: {3}'.format
MESSAGE_REGEX = re.compile(
    (r"""
        ^
        (?P<file_name> .+)      \(          # File Name
        (?P<line_number> \d+)   ,\s         # Line Number
        (?P<column_number> \d+) \)\s*       # Column Number
        (?P<message_type> \w+)  \s*:\s*     # Message Type
        (?P<content> .+)        \n          # Message Content
        (?P<context> .* \n\s*   \^)?        # Message Context
    """),
    flags=re.MULTILINE | re.IGNORECASE | re.VERBOSE
)


# Commands
class NimClearErrors(NimLimeMixin, ApplicationCommand):
    """ Clears error and warning marks generated by the Nim check commands. """
    settings_selector = 'check.clear_errors'

    @catch_errors
    def run(self, *args, **varargs):
        current_view = sublime.active_window().active_view()
        current_view.erase_regions(ERROR_REGION_TAG)
        current_view.erase_regions(WARN_REGION_TAG)
        sublime.status_message('Cleared Nim Check Errors & Hints')


class NimCheckCurrentView(NimLimeOutputMixin, ApplicationCommand):
    """ Checks the current Nim file for errors. """
    requires_nim_syntax = True

    settings_selector = 'check.current_file'
    setting_entries = (
        NimLimeOutputMixin.setting_entries,
        ('verbosity', '{0}.verbosity', 2),
        ('highlight_errors', '{0}.highlight_errors', True),
        ('highlight_warnings', '{0}.highlight_warnings', True),
        ('include_context', '{0}.list.include_context', True),
        ('list_errors', '{0}.list.show_errors', True),
        ('list_warnings', '{0}.list.show_warnings', True),
        ('move_cursor', '{0}.list.move_cursor', True)
    )

    @send_self
    @catch_errors
    def run(self, *args, **varargs):
        this = yield
        window = sublime.active_window()
        view = window.active_view()
        view_name = os.path.split(view.file_name() or view.name())[1]

        frames = ['Running Nim Check' + f for f in busy_frames]
        stop_status_loop = loop_status_msg(frames, 0.15)

        # Save view text
        if view.is_dirty():
            view.run_command('save')

        # Run 'nim check' on the current view and retrieve the output.
        # project_file = get_nim_project(window, view) or view.file_name()
        process, stdout, stderr, error = yield run_nimcheck(
            view.file_name(), this.send, self.verbosity
        )
        yield stop_status_loop(get_next_method(this))

        if handle_process_error(error, 'Nim Check Failed', 'Nim'):
            yield

        messages = parse_nimcheck_output(stdout)
        sublime.status_message('Nim Check Finished.')

        self.highlight_and_list_messages(messages, window, view)

        if self.send_output:
            if self.raw_output:
                content = stdout
            else:
                gen = (m[5] for m in messages if view_name == m[0])
                content = '\n'.join(gen)
            self.write_to_output(content, window, view)
        yield

    def highlight_and_list_messages(self, messages, window, view):
        """
        Highlight and list messages gathered from `nim check` output.
        :type messages: list[str]
        :type window: Any
        :type view: Any
        """
        view_name = os.path.split(view.file_name() or view.name())[1]

        # For listing
        if self.list_errors or self.list_warnings:
            quick_message_list = []
            point_list = []

        # For highlighting
        if self.highlight_errors:
            error_region_list = []
        if self.highlight_warnings:
            warn_region_list = []

        for file_name, row, column, kind, message, all_msg in messages:
            # TODO: more robust in case multiple names are allowed, PENDING https://github.com/nim-lang/Nim/pull/8614
            file_name = os.path.basename(file_name)
            if file_name.lower() != view_name.lower():
                continue

            # For listing
            if self.list_errors or self.list_warnings:
                point = view.text_point(row, column)
                point_list.append(point)

            # For highlighting
            message_point = view.text_point(row, column)
            message_region = trim_region(view, view.line(message_point))

            if kind == 'Error':
                # For listing
                if self.list_errors:
                    if self.include_context:
                        quick_message_list.append(all_msg.split('\n'))
                    else:
                        quick_message_list.append(all_msg.split('\n')[0])

                # For highlighting
                if self.highlight_errors:
                    error_region_list.append(message_region)
            else:
                # For listing
                if self.list_warnings:
                    if self.include_context:
                        quick_message_list.append(all_msg.split('\n'))
                    else:
                        quick_message_list.append(all_msg.split('\n')[0])

                # For highlighting
                if self.highlight_warnings:
                    warn_region_list.append(message_region)

        if self.highlight_errors:
            view.add_regions(
                ERROR_REGION_TAG,
                error_region_list,
                'invalid.illegal',
                ERROR_REGION_MARK,
                ERROR_REGION_STYLE
            )

        if self.highlight_warnings:
            view.add_regions(
                WARN_REGION_TAG,
                warn_region_list,
                'invalid.deprecated',
                ERROR_REGION_MARK,
                ERROR_REGION_STYLE
            )

        if self.list_errors or self.list_warnings:
            def _goto_error(choice):
                if choice != -1:
                    chosen_point = point_list[choice]
                    view.show(chosen_point)
                    if self.move_cursor:
                        view.sel().clear()
                        view.sel().add(sublime.Region(chosen_point))

            if self.include_context:
                window.show_quick_panel(
                    quick_message_list, _goto_error, sublime.MONOSPACE_FONT
                )
            else:
                window.show_quick_panel(quick_message_list, _goto_error)


class NimCheckOnSaveListener(NimCheckCurrentView, EventListener):
    """Runs the Nim Check command when the current file is saved."""
    settings_selector = 'check.on_save'

    def on_post_save(self, view):
        if self.enabled and view_has_nim_syntax(view):
            self.run()


class NimCheckFile(NimLimeOutputMixin, ApplicationCommand):
    """ Check an external nim file """
    requires_nim_syntax = True

    settings_selector = 'check.external_file'
    setting_entries = (
        NimLimeOutputMixin.setting_entries,
        ('show_output', '{0}.show_output', True),
        ('remember_input', '{0}.remember_input', True),
        ('include_context', '{0}.output.include_context', True)
    )

    last_entry = ''

    @send_self
    @catch_errors
    def run(self, *args, **varargs):
        this = yield
        window = sublime.active_window()
        view = window.active_view()

        # Retrieve user input
        initial_text = ''
        if self.remember_input:
            initial_text = self.last_entry

        path = yield window.show_input_panel(
            'File to check?', initial_text, this.send, None, None
        )
        self.last_entry = path

        if not os.path.isfile(path):
            sublime.error_message(
                'File \'{0}\' does not exist, or isn\'t a file.'.format(path)
            )
            yield

        # Run 'nim check' on the external file.
        frames = ['Checking External File' + f for f in busy_frames]
        stop_status_loop = loop_status_msg(frames, 0.25)

        process, stdout, stderr, error = yield run_nimcheck(
            path, this.send, self.verbosity
        )
        yield stop_status_loop(get_next_method(this))

        if handle_process_error(error, 'Nim Check Failed', 'Nim'):
            yield

        # Prepare output
        error_list = parse_nimcheck_output(stdout)
        error_output = '\n'.join(
            [error[5] for error in error_list]
        )

        # Stop the status loop
        sublime.status_message('External File Checked.')

        # Print to the output view
        if self.send_output or True:
            self.write_to_output(error_output, window, view)

        yield


# Utility functions
def run_nimcheck(file_path, callback, verbosity=2):
    """
    Run the Nim compiler in 'check' mode.
    :type file_path: str
    :type callback: (tuple) -> None
    :type verbosity: int
    :rtype: Any
    """
    # Prepare the regex's
    verbosity_str = '--verbosity:' + str(verbosity)
    return run_process(
        (configuration.nim_exe, 'check', verbosity_str, '-d:NimLime', file_path),
        callback, stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
    )


def parse_nimcheck_output(output):
    # Retrieve and convert the matches
    """
    Parse output of `nim check`
    :param output:
    :type output:
    :return:
    :rtype:
    """
    message_list = []
    for match in MESSAGE_REGEX.finditer(output):
        message_list.append((
            match.group('file_name'),
            int(match.group('line_number')) - 1,
            int(match.group('column_number')) - 1,
            match.group('message_type'),
            match.group('content'),
            match.group(0),
        ))

    # Sort the error list by line
    message_list.sort(key=lambda item: item[1])
    return message_list
